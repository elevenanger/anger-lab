package exploitableparallelism.renderer;

import cn.anger.util.exception.LaunderThrowable;
import cn.anger.util.timer.stopwatch.StopWatch;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;

/**
 * @author : anger
 * 在页面渲染的基础上加上一个广告的渲染
 * 设置一个超时时间，如果广告没有在指定时间内返回则渲染默认的广告
 */
public class PageAndAdRenderer extends SimpleImageRenderer {
    private static final long TIME_BUDGET = 50_000_000;
    private final ExecutorService exec =
        Executors.newFixedThreadPool(10);

    @Override
    void renderPage(CharSequence source) {
        StopWatch watch = StopWatch.get();
        watch.start("page and ad renderer");
        List<Callable<ImageData>> datas = new ArrayList<>();
        scanForImageInfo(source)
            .forEach(imageInfo -> datas.add(imageInfo::downloadImage));
        List<Future<ImageData>> futures = new ArrayList<>();
        try {
            futures = exec.invokeAll(datas);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        renderAd();
        renderText(source);

        try {
            for (Future<ImageData> future : futures)
                renderImage(future.get());
        } catch (ExecutionException e) {
            throw LaunderThrowable.launderThrowable(e.getCause());
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        watch.stopAndPrint();

    }

    private void renderAd() {
        long endNanos = System.nanoTime() + TIME_BUDGET;
        Future<SimpleTextAd> future = exec.submit(() -> new SimpleTextAd("simple").get());
        SimpleTextAd ad;
        try {
            long timeLeft = endNanos - System.nanoTime();
            // 设置超时时间
            ad = future.get(timeLeft, TimeUnit.NANOSECONDS);
        } catch (ExecutionException | TimeoutException e) {
            // 超时则设置为默认的 Ad
            ad = SimpleTextAd.DEFAULT;
            future.cancel(true);
        } catch (InterruptedException e) {
            ad = SimpleTextAd.DEFAULT;
            Thread.currentThread().interrupt();
        }
        System.out.println(ad);
    }

}
